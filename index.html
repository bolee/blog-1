<!doctype html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="考拉前端团队博客">
<meta property="og:url" content="https://blog.kaolafed.com/index.html">
<meta property="og:site_name" content="考拉前端团队博客">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="考拉前端团队博客">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://blog.kaolafed.com/"/>





  <title>考拉前端团队博客</title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">考拉前端团队博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/08/11/HTTPS协议浅析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/11/HTTPS协议浅析/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T09:28:18+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="HTTPS协议浅析"><a href="#HTTPS协议浅析" class="headerlink" title="HTTPS协议浅析"></a>HTTPS协议浅析</h1><hr>
<p>首先，我们在讲HTTPS之前先了解下为什么摒弃HTTP。</p>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>明文传输协议，交互过程以及数据传输都没有进行加密，通信双方也没有进行任何认证，通信过程非常容易遭遇劫持、监听、篡改，严重情况下，会造成恶意的流量劫持等问题，甚至造成个人隐私泄露（比如银行卡卡号和密码泄露）等严重的安全问题。</p>
<h3 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h3><p>超文本安全传输协议,和HTTP相比,多了一个SSL/TSL的认证过程,端口为443。<br>HTTP协议直接放置在TCP协议之上,而HTTPS在HTTP和TCP中间加上一层加密层。如图2-1所示。<br><img src="https://haitao.nos.netease.com/a7cf29cb-9134-4762-847f-49c5a308fc93.png" alt="HTTPS"><br>图2-1</p>
<h3 id="HTTPS流程解析"><a href="#HTTPS流程解析" class="headerlink" title="HTTPS流程解析"></a>HTTPS流程解析</h3><p>首先，我们来看一下HTTPS的简要流程图（如图3-1）。<br><img src="https://haitao.nos.netease.com/291669a5-da1e-4512-a4a4-0978cff1bb23.png" alt="HTTPS"><br>图3-1</p>
<p>1.客户端先向服务端发送一次HTTPS的连接请求。HTTPS服务端返回CA证书和加密公钥public key(非对称加密，如RSA)。<br>2.客户端用预设的CA列表验证证书，若证书有问题则提示风险。<br>3.客户端生成随机对称密钥，并通过第一步骤中的public key做加密（如AES对称加密）<br>4.将加密后的对称密钥发送给HTTPS服务端<br>5.HTTPS服务端用自己的非对称密钥private key解密，得到第三步的随机对称密钥<br>6.之后双方传送数据都用第五步得到的对称密钥加密后通信</p>
<p><strong>注意点：</strong></p>
<blockquote>
<ol>
<li><p>第一步中为什么使用非对称加密（如RSA）？<br> 因为非对称加密中，公钥加密的数据，有且只有唯一的私钥才能够解密。<strong>栗子</strong>：我有N把锁但只对应一把钥匙，这把钥匙保存在HTTPS服务器中，锁通过第一步的请求分发给各个客户端。</p>
</li>
<li><p>第三步中为什么使用对称加密（如AES）?<br> 因为非对称加密的解密过程极其消耗CPU资源，如果在通信过程中均使用非对称加密，会对服务器产生巨大的压力。因此非对称加密只是在对称密钥交换或者CA签名的时候使用（第一步和第五步）。之后一直使用对称加密进行通信，因为对称加密的效率高、速度快。<br> <strong>栗子</strong>：对称加密就是一把锁对应一把钥匙，第四步就是客户端把自己的钥放进过public key这把锁里，然后发给HTTPS服务端，服务端用自己的private key打开这把锁，得到了里面的对称密钥。这样客户端和服务端双方手里都拿着对称密钥，之后就可以拿着这把锁互相加解密了。</p>
</li>
<li><p>为什么需要CA数字证书？<br> 数字证书有三个功能：<br> 1.身份授权。确保浏览器访问的网站是经过CA验证的可信任的网站；<br> 2.分发公钥。每个数字证书都包含了注册者生成的公钥（验证确保是合法的，非伪造的公钥）。在SSL握手时会通过certificate消息传输给客户端；<br> 3.验证证书合法性。客户端接收到数字证书后，会对证书合法性进行验证。只有验证通过后的证书，才能够进行后续通信过程（通过数字签名防伪SHA-RSA）。<br><strong>如果没有数字证书，第一步中的非对称密钥可能会被中间人拦截，然后自己创建一个新的非对称密钥给客户端，从而导致客户端和服务端的通信均可被中间人解密了</strong></p>
</li>
</ol>
</blockquote>
<p>综上所述，如图3-2，非对称加密算法（公钥和私钥）交换对称密钥+数字证书验证身份（验证公钥是否是伪造的）+利用对称密钥加解密后续传输的数据=安全<br><img src="https://haitao.nos.netease.com/113c9ab4-1787-418f-b3da-66482f5ccb4f.png" alt="HTTPS"><br>图3-2</p>
<p>HTTPS基本的流程如上所示，其中的非对称加密、对称加密和数字签名可以展开很多篇幅，这里就不详细展开了。有兴趣的同学可以对应用密码学做相应的了解，可能对HTTPS的加解密过程会有更深入的理解。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/08/11/「译」PromisesA+规范/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/11/「译」PromisesA+规范/" itemprop="url">
                  未命名
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-11T09:28:18+08:00">
                2017-08-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <hr>
<p>title:「译」Promises/A+规范</p>
<h2 id="date-2017-07-31"><a href="#date-2017-07-31" class="headerlink" title="date:2017-07-31"></a>date:2017-07-31</h2><!-- 为了更方便归档，请先完善以上信息，正文贴下面 -->
<!--
注意点：
0. 文章中的资源（主要是图片）引用请使用 HTTPS
1. 文章末可以加上自己的署名，如： by [Kaola](http://www.kaola.com)
2. 最好不要用 NOS 图床，感觉加防盗链是迟早的事
3. 文章会定期归档到 https://blog.kaolafed.com/
-->
<p><a href="https://promisesaplus.com/" target="_blank" rel="external">官网原文</a></p>
<p><strong>一份针对健全、通用JavaScript promises对象的开放标准 — 由实现者制定，供实现者参考。</strong></p>
<p>一个 <em><code>promise</code></em> 对象代表一个异步操作的最终结果。与promise进行交互的主要方式是通过它的 <strong><code>then</code></strong> 方法，通过该方法注册回调函数，进而接受promise对象最终的值（value）或不能完成（fulfill）的原因（reason）。</p>
<p>本规范详细阐述了 <strong><code>then</code></strong> 方法的行为，给所有遵循本规范的promise实现提供了一份通用的实现基础。所以本规范可以认为是非常稳定的。尽管 Promises/A+ 组织可能偶尔会为了处理一些新发现的边界情况（corner cases）对本规范进行微小的向后兼容的修正，如果将要加入较大的不兼容的修正，我们一定会进行仔细详尽的考虑、讨论以及测试。</p>
<p>从历史上看，本规范是对先前 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="external">Promises/A</a> 规范条款的澄清明确，一方面对其扩展进而覆盖 <em>事实(de facto)</em> 行为（译者注：事实行为应该代表Promise/A中那些已经被广泛采用实现并且规范化的事实标准）；另一方面删除了其中没有规范化或者存在问题的规范条款。</p>
<p>最后，本规范的核心不会讨论如何创建（create）、完成（fulfill）或者拒绝（reject）promises对象，而是会专注于如何提供一个通用的 <strong><code>then</code></strong> 方法。其它相关规范的未来工作可能会涉及上面的三个主题。</p>
<h2 id="1-术语（Terminology）"><a href="#1-术语（Terminology）" class="headerlink" title="1. 术语（Terminology）"></a>1. 术语（Terminology）</h2><p><strong>1.1</strong> “promise” 是一个遵循本规范、并拥有 <strong><code>then</code></strong> 方法的对象或函数。</p>
<p><strong>1.2</strong> “thenable” 是一个定义了 <strong><code>then</code></strong> 方法的对象或函数。</p>
<p><strong>1.3</strong> “value” 是JavaScript中任意一种合法值(包括 <strong><code>undefined</code></strong>，”thenable”以及”promise”)。</p>
<p><strong>1.4</strong> “exception” 是一个使用 <strong><code>throw</code></strong> 语句抛出的值。</p>
<p><strong>1.5</strong> “reason” 是一个指示了promise为何被拒绝（rejected）的值。</p>
<h2 id="2-要求（Requirements）"><a href="#2-要求（Requirements）" class="headerlink" title="2. 要求（Requirements）"></a>2. 要求（Requirements）</h2><h3 id="2-1-Promise-的状态"><a href="#2-1-Promise-的状态" class="headerlink" title="2.1 Promise 的状态"></a>2.1 Promise 的状态</h3><p>一个 Promise 必须是以下三种状态之一：等待态（pending）、完成态（fulfilled）或拒绝态（rejected）。</p>
<h4 id="2-1-1-处于等待态（pending）时，promise-对象："><a href="#2-1-1-处于等待态（pending）时，promise-对象：" class="headerlink" title="2.1.1 处于等待态（pending）时，promise 对象："></a>2.1.1 处于等待态（pending）时，promise 对象：</h4><ul>
<li><strong>2.1.1.1</strong> 可以跳转至完成态或拒绝态</li>
</ul>
<h4 id="2-1-2-处于执行态（fulfilled）时，promise-对象："><a href="#2-1-2-处于执行态（fulfilled）时，promise-对象：" class="headerlink" title="2.1.2 处于执行态（fulfilled）时，promise 对象："></a>2.1.2 处于执行态（fulfilled）时，promise 对象：</h4><ul>
<li><p><strong>2.1.2.1</strong> 不能跳转至任何其它状态</p>
</li>
<li><p><strong>2.1.2.2</strong> 必须拥有一个固定不可变的值(value)</p>
</li>
</ul>
<h4 id="2-1-3-处于拒绝态（rejected），promise-对象："><a href="#2-1-3-处于拒绝态（rejected），promise-对象：" class="headerlink" title="2.1.3 处于拒绝态（rejected），promise 对象："></a>2.1.3 处于拒绝态（rejected），promise 对象：</h4><ul>
<li><p><strong>2.1.3.1</strong> 不能跳转至任何其它状态</p>
</li>
<li><p><strong>2.1.3.2</strong> 必须拥有一个固定不可变的原因(reason)</p>
</li>
</ul>
<blockquote>
<p>这里的“固定不可变”指的是同一个值（identity）（例如，可通过 <strong><code>===</code></strong> 的比较），但并不意味深层次的同一性（译者注：对于复杂深层次对象，深层次属性值的更改不代表promise的值或原因的变化）。</p>
</blockquote>
<h3 id="2-2-then-方法"><a href="#2-2-then-方法" class="headerlink" title="2.2 then 方法"></a>2.2 <strong><code>then</code></strong> 方法</h3><p>一个 promise 对象必须提供一个 <strong><code>then</code></strong> 方法来访问其当前值、最终的值或原因。</p>
<p>promise 对象的 <strong><code>then</code></strong> 方法接受两个参数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise.then(onFulfilled, onRejected)</div></pre></td></tr></table></figure>
<h4 id="2-2-1-onFulfilled-和-onRejected-都是可选参数。"><a href="#2-2-1-onFulfilled-和-onRejected-都是可选参数。" class="headerlink" title="2.2.1 onFulfilled 和 onRejected 都是可选参数。"></a>2.2.1 <strong><code>onFulfilled</code></strong> 和 <strong><code>onRejected</code></strong> 都是可选参数。</h4><ul>
<li><p><strong>2.2.1.1</strong> 如果 <strong><code>onFulfilled</code></strong> 不是函数，必须将其忽略</p>
</li>
<li><p><strong>2.2.1.2</strong> 如果 <strong><code>onRejected</code></strong> 不是函数，必须将其忽略</p>
</li>
</ul>
<h4 id="2-2-2-如果-onFulfilled-是一个函数："><a href="#2-2-2-如果-onFulfilled-是一个函数：" class="headerlink" title="2.2.2 如果 onFulfilled 是一个函数："></a>2.2.2 如果 onFulfilled 是一个函数：</h4><ul>
<li><p><strong>2.2.2.1</strong> 当 promise 完成（fulfilled）后必须对其调用，并且 promise 最终的值（value）作为第一个参数；</p>
</li>
<li><p><strong>2.2.2.2</strong>  promise 未完成（fulfilled）前，不能对其调用</p>
</li>
<li><p><strong>2.2.2.3</strong>  调用次数不可超过一次</p>
</li>
</ul>
<h4 id="2-2-3-如果-onRejected-是一个函数："><a href="#2-2-3-如果-onRejected-是一个函数：" class="headerlink" title="2.2.3 如果 onRejected 是一个函数："></a>2.2.3 如果 onRejected 是一个函数：</h4><ul>
<li><p><strong>2.2.3.1</strong> 当 promise 被拒绝（rejected）后必须对其调用，并且 promise 最终的原因（reason）作为第一个参数；</p>
</li>
<li><p><strong>2.2.3.2</strong> promise 未被拒绝（rejected）前，不能对其调用</p>
</li>
<li><p><strong>2.2.3.3</strong> 调用次数不可超过一次</p>
</li>
</ul>
<h4 id="2-2-4-onFulfilled-和-onRejected-只有在执行上下文（execution-context）堆栈仅包含平台代码（platform-code）时才可被调用。-3-1"><a href="#2-2-4-onFulfilled-和-onRejected-只有在执行上下文（execution-context）堆栈仅包含平台代码（platform-code）时才可被调用。-3-1" class="headerlink" title="2.2.4 onFulfilled 和 onRejected 只有在执行上下文（execution context）堆栈仅包含平台代码（platform code）时才可被调用。[3.1]"></a>2.2.4 <strong><code>onFulfilled</code></strong> 和 <strong><code>onRejected</code></strong> 只有在<a href="https://es5.github.io/#x10.3" target="_blank" rel="external">执行上下文（execution context）</a>堆栈仅包含平台代码（platform code）时才可被调用。[<a href="#3.1">3.1</a>]</h4><h4 id="2-2-5-onFulfilled-和-onRejected-必须被作为函数调用（例如没有-this-值）。-3-2"><a href="#2-2-5-onFulfilled-和-onRejected-必须被作为函数调用（例如没有-this-值）。-3-2" class="headerlink" title="2.2.5 onFulfilled 和 onRejected  必须被作为函数调用（例如没有 this 值）。[3.2]"></a>2.2.5 <strong><code>onFulfilled</code></strong> 和 <strong><code>onRejected</code></strong>  必须被作为函数调用（例如没有 <strong><code>this</code></strong> 值）。[<a href="#3.2">3.2</a>]</h4><h4 id="2-2-6-then-方法可以被同一个promise对象调用多次。"><a href="#2-2-6-then-方法可以被同一个promise对象调用多次。" class="headerlink" title="2.2.6 then 方法可以被同一个promise对象调用多次。"></a>2.2.6 <strong><code>then</code></strong> 方法可以被同一个promise对象调用多次。</h4><ul>
<li><p><strong>2.2.6.1</strong> 如果/当 <strong><code>promise</code></strong> 执行完成后，所有 <strong><code>onFulfilled</code></strong> 回调函数，必须按照其最初调用 <strong><code>then</code></strong> 的顺序依次执行。</p>
</li>
<li><p><strong>2.2.6.2</strong> 如果/当 <strong><code>promise</code></strong> 执行被拒绝后，所有 <strong><code>onRejected</code></strong> 回调函数，必须按照其最初调用 <strong><code>then</code></strong> 的顺序依次执行。</p>
</li>
</ul>
<h4 id="2-2-7-then-方法必须返回一个promise对象-3-3"><a href="#2-2-7-then-方法必须返回一个promise对象-3-3" class="headerlink" title="2.2.7 then 方法必须返回一个promise对象 [3.3]"></a>2.2.7 <strong><code>then</code></strong> 方法必须返回一个promise对象 [<a href="#3.3">3.3</a>]</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise2 = promise1.then(onFulfilled, onRejected);</div></pre></td></tr></table></figure>
<ul>
<li><p><strong>2.2.7.1</strong> 如果 <strong><code>onFulfilled</code></strong> 或者 <strong><code>onRejected</code></strong> 返回一个值 <strong><code>x</code></strong> ，运行 <em>Promise Resolution Procedure</em> <strong><code>[[Resolve]](promise2, x)</code></strong></p>
</li>
<li><p><strong>2.2.7.2</strong> 如果 <strong><code>onFulfilled</code></strong> 或者 <strong><code>onRejected</code></strong> 抛出一个异常 <strong><code>e</code></strong>，则 <strong><code>promise2</code></strong> 必须拒绝执行，并以 <strong><code>e</code></strong> 作为拒绝的原因。</p>
</li>
<li><p><strong>2.2.7.3</strong> 如果 <strong><code>onFulfilled</code></strong> 不是函数，并且 <strong><code>promise1</code></strong> 执行完成，<strong><code>promise2</code></strong> 必须成功完成并返回相同的值（value）。</p>
</li>
<li><p><strong>2.2.7.4</strong> 如果 <strong><code>onRejected</code></strong> 不是函数，并且 <strong><code>promise1</code></strong> 执行被拒绝，<strong><code>promise2</code></strong> 必须以相同的原因（reason）被拒绝执行。</p>
</li>
</ul>
<h3 id="2-3-Promise-Resolution-Procedure（PRP）"><a href="#2-3-Promise-Resolution-Procedure（PRP）" class="headerlink" title="2.3 Promise Resolution Procedure（PRP）"></a>2.3 Promise Resolution Procedure（PRP）</h3><p><strong><code>Promise Resolution Procedure</code></strong> 是一个抽象的操作，以一个 promise 对象和一个值（value）作为输入参数，我们表示为 <strong><code>[[Resolve]](promise, x)</code></strong>。如果 <strong><code>x</code></strong> 是一个 <strong><code>thenable</code></strong> 的对象（即一个拥有 <strong><code>then</code></strong> 方法的函数或对象），并且其行为和一个promise对象至少有些许相似，PRP就会尝试让 <strong><code>promise</code></strong> 接受 <strong><code>x</code></strong> 的状态；否则，其用 <strong><code>x</code></strong> 的值来执行完成 <strong><code>promise</code></strong>。</p>
<p>这种处理 <strong><code>thenables</code></strong> 的方式使得各种promise的实现可以互通，只要它们开放出一个与Promise/A+协议兼容的 <strong><code>then</code></strong> 方法即可。这也使得遵循 Promise/A+ 规范的实现可以 <strong><code>接受</code></strong> （译者注：这里的 <strong><code>接受</code></strong>, 原文使用了assimilate这个单词，原意为消化吸收，这里面指的就是可以接受其它非规范化实现的then方法）那些未遵循规范实现的合理的 <strong><code>then</code></strong> 方法。</p>
<p>通过以下步骤来运行 <strong><code>[[Resolve]](promise, x)</code></strong>：</p>
<ul>
<li><strong>2.3.1</strong> 如果 <strong><code>promise</code></strong> 和 <strong><code>x</code></strong> 引用同一对象，以 <strong><code>TypeError</code></strong> 为原因拒绝执行 <strong><code>promise</code></strong>。</li>
</ul>
<ul>
<li><p><strong>2.3.2</strong> 如果 <strong><code>x</code></strong> 是一个promise对象，则promise采纳 <strong><code>x</code></strong> 的状态 [<a href="#3.4">3.4</a>]：</p>
<ul>
<li><p><strong>2.3.2.1</strong> 如果 <strong><code>x</code></strong> 处于等待态（pending），<strong><code>promise</code></strong> 必须保持为等待态（pending）直到 <strong><code>x</code></strong> 完成（fulfilled）或 拒绝（rejected）。</p>
</li>
<li><p><strong>2.3.2.2</strong> 如果/当 <strong><code>x</code></strong> 已经完成（fulfilled），使用相同的值执行完成 <strong><code>promise</code></strong>。</p>
</li>
<li><p><strong>2.3.2.3</strong> 如果/当 <strong><code>x</code></strong> 被拒绝（rejected），使用相同的原因拒绝执行 <strong><code>promise</code></strong>。</p>
</li>
</ul>
</li>
<li><p><strong>2.3.3</strong> 其它情况，如果 <strong><code>x</code></strong> 为一个对象或者函数：</p>
<ul>
<li><p><strong>2.3.3.1</strong> 把 <strong><code>then</code></strong> 赋值为 <strong><code>x.then</code></strong>[<a href="#3.5">3.5</a>]</p>
</li>
<li><p><strong>2.3.3.2</strong> 如果取 <strong><code>x.then</code></strong> 的值时抛出错误 <strong><code>e</code></strong>，则使用 <strong><code>e</code></strong> 为原因拒绝 <strong><code>promise</code></strong>。</p>
</li>
<li><p><strong>2.3.3.3</strong> 如果 <strong><code>then</code></strong> 是一个函数，则以 <strong><code>x</code></strong> 作为 <strong><code>this</code></strong> 的值对其进行调用，并以 <strong><code>resolvePromise</code></strong> 作为第一个参数，<strong><code>x</code></strong> 作为第二个参数，其中:</p>
<ul>
<li><p><strong>2.3.3.3.1</strong> 如果/当以 <strong><code>y</code></strong> 值为参数调用 <strong><code>resolvePromise</code></strong> 时，则运行 <strong><code>[[Resolve]](promise, y)</code></strong>。</p>
</li>
<li><p><strong>2.3.3.3.2</strong> 如果/当以 <strong><code>r</code></strong> 原因为参数调用 <strong><code>rejectPromise</code></strong> 时，则使用原因 <strong><code>r</code></strong> 拒绝执行 <strong><code>promise</code></strong>。</p>
</li>
<li><p><strong>2.3.3.3.3</strong> 如果 <strong><code>resolvePromise</code></strong> 和 <strong><code>rejectPromise</code></strong> 都被调用，或者被使用相同的参数调用了多次，则首次调用将被优先采用，其它调用将被忽略。</p>
</li>
<li><p><strong>2.3.3.3.4</strong> 如果调用 <strong><code>then</code></strong> 方法过程中抛出异常 <strong><code>e</code></strong>：</p>
<ul>
<li><p><strong>2.3.3.3.4.1</strong> 如果 <strong><code>resolvePromise</code></strong> 或 <strong><code>rejectPromise</code></strong> 都已经被调用，则忽略该异常。</p>
</li>
<li><p><strong>2.3.3.3.4.2</strong> 否则使用 <strong><code>e</code></strong> 为原因拒绝执行 <strong><code>promise</code></strong>。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>2.3.3.4</strong> 如果 <strong><code>then</code></strong> 不是函数，以 <strong><code>x</code></strong> 为值完成 <strong><code>promise</code></strong>。</p>
</li>
</ul>
</li>
<li><p><strong>2.3.4</strong> 如果 <strong><code>x</code></strong> 不是对象或者函数，以 <strong><code>x</code></strong> 为值完成 <strong><code>promise</code></strong>。</p>
</li>
</ul>
<p>如果一个promise对象被一个处于循环thenable链中的thenable对象解决（resolve），由于 <strong><code>[[Resolve]](promise, thenable)</code></strong> 的递归本质会使得其再次被调用，按照上面的算法，这种情况将导致无限递归。本规范鼓励实现者检测这种递归情况的出现，并使用带有一定信息的 <strong><code>TypeError</code></strong> 作为原因拒绝执行 <strong><code>promise</code></strong> [<a href="#3.6">3.6</a>]，但规范不对此检测做强制要求。</p>
<h2 id="3-注释"><a href="#3-注释" class="headerlink" title="3. 注释"></a>3. 注释</h2><ul>
<li><p><strong>3.1</strong> 这里“平台代码”指的是引擎(engine)、环境(environment)以及 promise 的实现代码（implementation code）。实际上，这个要求确保了 <strong><code>onFulfilled</code></strong> 和 <strong><code>onRejected</code></strong> 方法能够异步执行，即在调用 <strong><code>then</code></strong> 方法的那个事件循环之后的新执行栈中异步执行。这个要求可以通过“宏任务（macro-task）”机制（例如 <a href="https://html.spec.whatwg.org/multipage/webappapis.html#timers" target="_blank" rel="external"><strong><code>setTimeout</code></strong></a> 或者 <a href="https://dvcs.w3.org/hg/webperf/raw-file/tip/specs/setImmediate/Overview.html#processingmodel" target="_blank" rel="external"><strong><code>setImmediate</code></strong></a>）或者“微任务（micro-task）”机制（例如 <a href="https://dom.spec.whatwg.org/#interface-mutationobserver" target="_blank" rel="external"><strong><code>MutationObserver</code></strong></a> 或者 <a href="http://nodejs.org/api/process.html#process_process_nexttick_callback" target="_blank" rel="external"><strong><code>process.nextTick</code></strong></a>）来实现。既然 promise 的实现代码本身也被认为是“平台代码”，所以其自身可能也会包含一种任务调度队列或者“trampoline”控制结构来对其处理程序进行调用。</p>
</li>
<li><p><strong>3.2</strong> 也就是说，<strong><code>this</code></strong> 的值，在严格模式（strict）下为 <strong><code>undefined</code></strong>；在非严格模式()下为全局对象（global object）。</p>
</li>
<li><p><strong>3.3</strong> 在满足所有要求的情况下，现实实现中可能允许 <strong><code>promise2 === promise1</code></strong>。每个实现都需要说明其是否允许出现 <strong><code>promise2 === promise1</code></strong>，以及在何种条件下出现。</p>
</li>
<li><p><strong>3.4</strong> 通常来说，只有当 <strong><code>x</code></strong> 是从当前实现中定义出来的，我们才知道它是一个真正的promise对象。这条规则允许使用特定实现中的方法去采用符合规范的promise对象的状态。</p>
</li>
<li><p><strong>3.5</strong> 这一步骤中，我们首先会存储一个指向 x.then 的引用，然后测试该调用，之后调用该引用，这一系列过程为了防止对 x.then 属性的多处访问。这些预防措施对于保证访问器属性的一致性至关重要，因为其值可能在多次取值期间发生变化。</p>
</li>
<li><p><strong>3.6</strong> 本规范的实现 <em>不应该</em> 任意限定thenable链的深度，并认定只要超过了该限定递归就是无限的。只有真正的循环递归才应导致一个 <strong><code>TypeError</code></strong>；如果一条无限长链上的thenable对象各不相同，那么无限递归下去则是正确的行为。</p>
</li>
</ul>
<p>By <a href="https://github.com/llwanghong/blog" target="_blank" rel="external">Hong</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/08/10/HTTP请求中的Form Data与Request Payload的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/10/HTTP请求中的Form Data与Request Payload的区别/" itemprop="url">
                  HTTP请求中的Form Data与Request Payload的区别
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-10T00:00:00+08:00">
                2017-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前端开发中经常会用到AJAX发送异步请求，对于POST类型的请求会附带请求数据。而常用的两种传参方式为：Form Data 和 Request Payload。</p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163614-9ac78ea4-7def-11e7-9067-77d73a5d841c.jpg" alt="121212"></p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163628-a3e89d48-7def-11e7-869a-1f818fd97149.jpg" alt="334343"></p>
<h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><p>使用get请求时，参数会以key=value的形式拼接在请求的url后面。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://m.baidu.com/address/getlist.html?limit=50&amp;offset=0&amp;t=1502345139870</div></pre></td></tr></table></figure>
<p>但是受限于请求URL的长度限制，一般参数较少时会使用get请求。</p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><p>当参数数量较多，且对数据有一定安全性要求时，会考虑用post请求传递参数数据。POST请求的参数数据是在请求体中。</p>
<h4 id="方式一：-Form-Data形式"><a href="#方式一：-Form-Data形式" class="headerlink" title="方式一： Form Data形式"></a>方式一： Form Data形式</h4><p>当POST请求的请求头里设置Content-Type: application/x-www-form-urlencoded(默认), 参数在请求体以标准的Form Data的形式提交，以&amp;符号拼接，参数格式为key=value&amp;key=value&amp;key=value…</p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163839-45a49736-7df0-11e7-8f49-56b6744ca3fc.jpg" alt="3333"></p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163614-9ac78ea4-7def-11e7-9067-77d73a5d841c.jpg" alt="121212"></p>
<p>前端代码设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">xhr.setRequestHeader(&apos;Content-type&apos;, &apos;application/x-www-form-urlencoded&apos;);</div><div class="line">xhr.send(&apos;a=1&amp;b=2&amp;c=3&apos;);</div></pre></td></tr></table></figure>
<p>在servlet中，后端可以通过request.getParameter(name)的形式来获取表单参数。</p>
<h4 id="方式二：Request-Payload形式"><a href="#方式二：Request-Payload形式" class="headerlink" title="方式二：Request Payload形式"></a>方式二：Request Payload形式</h4><p>如果使用AJAX原生POST请求,请求头里设置Content-Type:application/json，请求的参数会显示在Request Payload中，参数格式为JSON格式：{“key”:”value”,”key”:”value”…}，这种方式可读性会更好。</p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163866-5b0876ec-7df0-11e7-873b-44731e1becc1.jpg" alt="444"></p>
<p><img src="https://user-images.githubusercontent.com/5309877/29163628-a3e89d48-7def-11e7-869a-1f818fd97149.jpg" alt="334343"></p>
<p>后端可以使用getRequestPayload方法来获取。</p>
<h2 id="Form-Data-和-Request-Payload-区别"><a href="#Form-Data-和-Request-Payload-区别" class="headerlink" title="Form Data 和 Request Payload 区别"></a>Form Data 和 Request Payload 区别</h2><ol>
<li><p>如果请求头里设置Content-Type: application/x-www-form-urlencoded，那么这个请求被认为是表单请求，参数出现在Form Data里，格式为key=value&amp;key=value&amp;key=value…</p>
</li>
<li><p>原生的AJAX请求头里设置Content-Type:application/json，或者使用默认的请求头Content-Type:text/plain;参数会显示在Request payload块里提交。</p>
</li>
</ol>
<p><strong>参考文档：</strong><br><a href="http://www.cnblogs.com/btgyoyo/p/6141480.html" target="_blank" rel="external">http://www.cnblogs.com/btgyoyo/p/6141480.html</a><br><a href="http://xiaobaoqiu.github.io/blog/2014/09/04/form-data-vs-request-payload/" target="_blank" rel="external">http://xiaobaoqiu.github.io/blog/2014/09/04/form-data-vs-request-payload/</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/08/06/组件的一些思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/08/06/组件的一些思考/" itemprop="url">
                  组件的一些思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-06T00:00:00+08:00">
                2017-08-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 为了更方便归档，请先完善以上信息，正文贴下面 -->
<!--
注意点：
0. 文章中的资源（主要是图片）引用请使用 HTTPS
1. 文章末可以加上自己的署名，如： by [Kaola](http://www.kaola.com)
2. 最好不要用 NOS 图床，感觉加防盗链是迟早的事
3. 文章会定期归档到 https://blog.kaolafed.com/
-->
<p>如今数据驱动视图的框架已经成为前端开发的主流，如react、vue、angular等，当然还包括我们用的regular。这些框架大大提高了我们的开发效率，但同时现在的页面结构越来越复杂，虽然有这些mv*的框架，但如果我们使用不当，也会造成状态数据管理混乱，代码难以维护的困扰。</p>
<p>因此组件化的思想就是为了提高开发效率和后期维护的效率。</p>
<h2 id="什么是组件化"><a href="#什么是组件化" class="headerlink" title="什么是组件化"></a>什么是组件化</h2><blockquote>
<p>一个组件只做一件事，基于功能做好职责划分。</p>
</blockquote>
<p>对组件的封装都是为了对数据逻辑业务的梳理，使得不同组件各司其职，即把大块的业务界面，拆分成若干小块，然后进行组装。当然这里不局限与js，其实css同样适用（如nec规范）。</p>
<h2 id="组件的划分"><a href="#组件的划分" class="headerlink" title="组件的划分"></a>组件的划分</h2><p><img src="https://user-images.githubusercontent.com/5706155/29003203-de472382-7ae4-11e7-94d2-d31f46bc8d76.jpg" alt="module-and-components"></p>
<h3 id="无状态组件"><a href="#无状态组件" class="headerlink" title="无状态组件"></a>无状态组件</h3><p>数据驱动视图，顾名思义视图的状态肯定是根据数据进行变化的，因此数据的状态管理就变得尤为重要。</p>
<p>无状态组件为只接受props，根据props的不同展示出不同的样式，并且会抛出事件来通知外部组件需要的更改（<em>ps. 按照react以及vue的单向绑定原则，props传入是不能被更改的，这和regular的双向绑定不同</em>)</p>
<blockquote>
<p>单向绑定能更好的帮助我们控制住数据的状态，特别对于越来越复杂的前端</p>
</blockquote>
<h3 id="UI组件"><a href="#UI组件" class="headerlink" title="UI组件"></a>UI组件</h3><p>这部分就是我们视图上看到的各个UI单元，如输入框、tab框、表格、下拉框等等，其中有一些其实可以是我们上述所说的无状态组件，我们常见的UI库如ant-design(react)、eleme-element(vue)以及nek、kmui等。</p>
<blockquote>
<p>特点：复用性强，根据接受参数显示不同的视图，以及开放一些接口与外部通信。就如同一个对html标签的扩展</p>
</blockquote>
<h3 id="业务组件"><a href="#业务组件" class="headerlink" title="业务组件"></a>业务组件</h3><p>就是按照一个页面的业务逻辑进行划分的单元，如优惠券、商品1x2、商品1x3、倒计时等等，它们中有一些有一定的复用性，但大部分可能只会在特定的业务中使用。它们里面是由一个个UI组件组成。</p>
<h3 id="容器组件"><a href="#容器组件" class="headerlink" title="容器组件"></a>容器组件</h3><p>一个包裹业务模块的盒子，一般来说一个业务模块的入口。它接收着业务组件所需要的所有数据，然后根据每个业务组件的需要来进行分发数据，使对应的数据进入到对应的业务组件中。如下是一个使用了redux和react的container组件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">import &#123;connect&#125; from &apos;react-redux&apos;;</div><div class="line"></div><div class="line">import Topic from &apos;../components/topic&apos;;</div><div class="line"></div><div class="line">const mapStateToProps = (state) =&gt; &#123;</div><div class="line">    return &#123;</div><div class="line">        info: state.topicInfo</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">const mapDispatchToProps = (dispatch) =&gt; &#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line">export default connect(mapStateToProps, mapDispatchToProps)(Topic)</div></pre></td></tr></table></figure>
<p>上面的container就是将topic的业务组件进行了一个包裹并将数据通过props传入给了topic。</p>
<h2 id="组件的原则"><a href="#组件的原则" class="headerlink" title="组件的原则"></a>组件的原则</h2><ol>
<li>state状态应尽量简单</li>
<li>单向原则，子组件不应该影响父组件，当某个子组件删除后，只会影响此子组件的UI展示，其他组件都不应该产生影响</li>
<li>参数的扁平化，接收的props应该尽量做到是基本数据类型。</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/30/Promise：从懵逼开始摸爬滚打/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/30/Promise：从懵逼开始摸爬滚打/" itemprop="url">
                  Promise：从懵逼开始摸爬滚打
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-30T00:00:00+08:00">
                2017-07-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 为了更方便归档，请先完善以上信息，正文贴下面 -->
<!--
注意点：
0. 文章中的资源（主要是图片）引用请使用 HTTPS
1. 文章末可以加上自己的署名，如： by [Kaola](http://www.kaola.com)
2. 最好不要用 NOS 图床，感觉加防盗链是迟早的事
3. 文章会定期归档到 https://blog.kaolafed.com/
-->
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>是的，Promise长期让我处在懵逼状态。就像高中学不会化学，可是总有人跟你说：化学，不是很简单吗？（再见）</p>
<p>找了几篇文章看，把我拉出懵逼状态的是同事的一句话和一篇文章，特此记录。</p>
<h4 id="话：“-then-参数就是向前面的异步函数注册成功和失败的回调”"><a href="#话：“-then-参数就是向前面的异步函数注册成功和失败的回调”" class="headerlink" title="话：“.then()参数就是向前面的异步函数注册成功和失败的回调”"></a>话：“.then()参数就是向前面的异步函数注册成功和失败的回调”</h4><h4 id="文：-你不懂JS-异步与性能-第三章-Promises"><a href="#文：-你不懂JS-异步与性能-第三章-Promises" class="headerlink" title="文： 你不懂JS: 异步与性能 第三章: Promises"></a>文： <a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&amp;%20performance/ch3.md" target="_blank" rel="external">你不懂JS: 异步与性能 第三章: Promises</a></h4><h2 id="我们经常写的异步回调出了什么问题？"><a href="#我们经常写的异步回调出了什么问题？" class="headerlink" title="我们经常写的异步回调出了什么问题？"></a>我们经常写的异步回调出了什么问题？</h2><ol>
<li>不好写不好看不好管理——引发对异步回调反感的直接原因。缺乏顺序性和可靠性。</li>
<li>callback代码流程是基于副作用的：一个函数会附带调用其他函数。</li>
<li>失去了对主流程的控制权，控制权在那些结果不可预测不可靠的代码块里。</li>
</ol>
<h4 id="如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。"><a href="#如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。" class="headerlink" title="如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。"></a>如果异步代码只是告诉我们它是否完成，而能由我们把握流程，拿回调用回调的权利，那事情就会靠谱很多。</h4><h2 id="什么是Promise"><a href="#什么是Promise" class="headerlink" title="什么是Promise"></a>什么是Promise</h2><h3 id="未来的值"><a href="#未来的值" class="headerlink" title="未来的值"></a>未来的值</h3><p>文中的例子我觉得很棒，再此简单重复：</p>
<table>
<thead>
<tr>
<th>买汉堡</th>
<th>请求与回调</th>
</tr>
</thead>
<tbody>
<tr>
<td>去麦当劳，要了板烧堡套餐，27块给收银员</td>
<td>发请求</td>
</tr>
<tr>
<td>收银员给我号码牌198，保证我会得到汉堡</td>
<td>得到Promise</td>
</tr>
<tr>
<td>等待叫号，发了票圈“等会儿吃板烧堡了开心”（我还没有得到汉堡，但是号码牌已经代表了汉堡，相当于一个占位符，与什么时候得到它并没有关系）</td>
<td>等待并处理其他事物(可以使用这个<em>未来</em>的结果)</td>
</tr>
<tr>
<td>“198号，您的套餐齐了”</td>
<td><em>未来的值</em>已经返回，许诺换回了真值</td>
</tr>
<tr>
<td>“不好意思，我们的板烧堡卖完了”</td>
<td>返回<em>未来的值</em>可能成功也可能失败</td>
</tr>
<tr>
<td>WTF, 我的号码永远不被叫到</td>
<td>还有可能回调永远被搁置</td>
</tr>
</tbody>
</table>
<h3 id="现在和稍后的值"><a href="#现在和稍后的值" class="headerlink" title="现在和稍后的值"></a>现在和稍后的值</h3><ol>
<li><p>现在的值</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var x, y = 2;</div><div class="line">console.log(x + y);</div></pre></td></tr></table></figure>
<p> 第二步的打印是基于x,y都已经被解析，是<em>现在值</em></p>
</li>
<li><p>稍后的值</p>
<p> 如果x,y解析需要时间，解析之后再进行处理，这就需要回调</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">function add(getX, getY, cb)&#123;</div><div class="line">    var x, y;</div><div class="line">    getX(function(xVal)&#123;</div><div class="line">        x = xVal;</div><div class="line">        if (y != undefined) &#123;</div><div class="line">            cb(x + y);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    getY(function(yVal)&#123;</div><div class="line">        y = yVal;</div><div class="line">        if (x != undefined) &#123;</div><div class="line">            cb(x + y);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">add(fetchX, fetchY, function(sum)&#123;</div><div class="line">    console.log(sum);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 从外部看，add()不关心现在x,y是否可用，内部将它们都当作未来的值。<strong>泛化</strong>了“现在”和“稍后”：所有的操作都变成异步的</p>
</li>
<li><p>Promise值</p>
<p> 用Promise来表达上面的例子</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">function add(xPromise, yPromise)&#123;</div><div class="line">    return Promise.all([xPromise, yPromise])</div><div class="line">    .then(function(values)&#123;</div><div class="line">        return values[0] + values[1];</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// fetchX(), fetchY()分别为它们的值返回一个Promise</div><div class="line">add(fetchX(), fetchY())</div><div class="line">.then(function(sum)&#123;    // 链在add()里的then之后</div><div class="line">    console.log(sum);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p> 上面代码中有两层Promise</p>
<ol>
<li>fetchX(), fetchY()被直接调用传入add()，返回值都是Promise，表示在<em>现在</em>或者<em>稍后</em>准备好，都将行为泛化为与时间无关。</li>
<li><p>add()创建返回Promise。用.then()等待x, y被解析出来</p>
<h4 id="注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。"><a href="#注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。" class="headerlink" title="注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。"></a>注意：Promise一旦被解析，就是外界不可变的，将解析值传给任何其他模块都是安全的，两个模块之间对解析值的监听互不干扰——不可变性。</h4></li>
</ol>
</li>
<li><p>完成事件</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">function foo(x)&#123;</div><div class="line">    // do async things</div><div class="line">    return listener;</div><div class="line">&#125;</div><div class="line"></div><div class="line">var evt = foo(&apos;result&apos;);</div><div class="line"></div><div class="line">evt.on(&apos;completion&apos;, function(val)&#123;</div><div class="line">    // do next tings width val</div><div class="line">&#125;);</div><div class="line"></div><div class="line">evt.on(&apos;failure&apos;, function(err)&#123;</div><div class="line">    // log wrong</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p> 将程序的控制权归还给调用方代码，一个耗时的函数在完成时发出通知，而不必关心外界的监听和处理</p>
</li>
<li><p>Promise“事件”</p>
<p> evt的监听能力是一个Promise的类比。</p>
<p> 在基于Promise的方式中，foo()会返回一个Promise实例。.then()注册了异步函数完成和拒绝事件</p>
</li>
</ol>
<h2 id="Promise的信任"><a href="#Promise的信任" class="headerlink" title="Promise的信任"></a>Promise的信任</h2><p>Promise是为什么，以及如何被设计为来解决<em>控制倒转</em>的信任问题</p>
<p>当你传递一个回调给一个工具函数foo()，它可能：</p>
<ol>
<li>调用回调太早</li>
<li>调用回调太晚（或者根本不调）</li>
<li>调用回调太多或太少</li>
<li>没能传递必要的参数和环境</li>
<li>吞掉了任何可能发生的错误/异常</li>
</ol>
<h3 id="调的太早"><a href="#调的太早" class="headerlink" title="调的太早"></a>调的太早</h3><p>即便是立即完成的Promise也不能被同步地监听<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new Promise(function(resolve)&#123;</div><div class="line">    resolve(42);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>即使在Promise调用then的时候已经被解析了，then中的回调也总是被异步地调用</p>
<h3 id="调得太晚"><a href="#调得太晚" class="headerlink" title="调得太晚"></a>调得太晚</h3><p>在resolve()或reject()被Promise创建机制调用的时候，注册在.then上的监听回调将会自动地被排程。这些被排程好的回调将在下一个异步时刻被可预测地触发。</p>
<p>当一个Promise被解析的时候，所有注册在then()上的回调都会被<strong>立即</strong>、按顺序地在下一个异步机会时被调用，且 没有任何在这些回调中发生的事情可以影响/推迟其他回调的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise(function(resolve, reject)&#123;&#125;);</div><div class="line"></div><div class="line">p.then(function(val)&#123;</div><div class="line">    p.then(function()&#123;</div><div class="line">        console.log(&apos;c: &apos;, val);    // c不能干扰并优先于b</div><div class="line">    &#125;);</div><div class="line">    console.log(&apos;a: &apos;, val);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p.then(function(val)&#123;</div><div class="line">    console.log(&apos;b: &apos;, val);</div><div class="line">&#125;);</div><div class="line">// a b c</div></pre></td></tr></table></figure>
<h4 id="Promise排程的怪象"><a href="#Promise排程的怪象" class="headerlink" title="Promise排程的怪象"></a>Promise排程的怪象</h4><p>链接在两个分离的Promise上的回调之间的相对顺序是无法可靠预测的。</p>
<p>如果两个Promise p1和p2都准备好被解析了，那么p1.then(); p2.then()应当归结为首先调用p1的回调，然后调用p2的回调。但是有时候情况是下面这样的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">var p3 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(&apos;A&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p1 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(p3);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">var p2 = new Promise(function(resolve, reject)&#123;</div><div class="line">    resolve(&apos;B&apos;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line">p1.then(function(v)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(function(v)&#123;</div><div class="line">    console.log(v);</div><div class="line">&#125;);</div><div class="line">// B A</div></pre></td></tr></table></figure></p>
<p>p1不是被一个立即值所解析的，而是由另一个promise p3所解析，p3被一个立即值“A”解析。这种行为将p3展开到p1，但是是异步的。在异步队列中，p1的回调位于p2的回调之后。</p>
<p>这是很微妙的噩梦，不应该依靠任何跨Promise的回调顺序/排程</p>
<h3 id="根本不调回调"><a href="#根本不调回调" class="headerlink" title="根本不调回调"></a>根本不调回调</h3><p>Promise有几种解决方式</p>
<ol>
<li>没有任何东西可以阻止Promise通知你它的解析。如果在Promise上注册了完成和拒绝回调，解析完成之后总有一个会被调用</li>
<li><p>如果Promise本身无论如何没有被解析呢？Promise使用了一个成为“竞赛(race)”的高级抽象</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">// 一个使Promise超时的工具</div><div class="line">function timeoutPromise(delay) &#123;</div><div class="line">	return new Promise(function(resolve,reject)&#123;</div><div class="line">		setTimeout(function()&#123;</div><div class="line">			reject( &quot;Timeout!&quot; );</div><div class="line">		&#125;, delay);</div><div class="line">	&#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">// 为`foo()`设置一个超时</div><div class="line">Promise.race( [</div><div class="line">	foo(),					// 尝试调用`foo()`</div><div class="line">	timeoutPromise( 3000 )	// 给它3秒钟</div><div class="line">] )</div><div class="line">.then(</div><div class="line">	function()&#123;</div><div class="line">		// `foo(..)`及时地完成了！</div><div class="line">	&#125;,</div><div class="line">	function(err)&#123;</div><div class="line">		// `foo()`不是被拒绝了，就是它没有及时完成</div><div class="line">		// 那么可以考察`err`来知道是哪种情况</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p> 这种超时模式有细节待考察，但是可以确保有delay的信号作为foo的结果，防止其无限地挂起我们的程序</p>
</li>
</ol>
<h3 id="调太少或太多次"><a href="#调太少或太多次" class="headerlink" title="调太少或太多次"></a>调太少或太多次</h3><p>太少：不被调用，上面已经说过<br>太多：Promise只能被解析一次。如果Promise的创建代码试着调用resolve()或reject()许多次，或者尝试用时调它们两个，Promise只接受第一次解析，而无声地忽略后面的尝试</p>
<p>因为Promise只能被解析一次，所以任何在then()上注册的回调函数将仅被调用一次。</p>
<h3 id="没能传入任何参数-环境"><a href="#没能传入任何参数-环境" class="headerlink" title="没能传入任何参数/环境"></a>没能传入任何参数/环境</h3><p>Promise可以拥有最多一个解析值（完成或拒绝）。</p>
<p>如果没有用一个值明确地解析它，解析值就是undefined。不管是什么值都会被传入所注册的（且适当的：完成或拒绝）回调中，不管是现在还是未来。</p>
<p>参数，如果你使用多个参数调用resolve()或者reject()，所有第一个参数之外的后续参数都会被无声忽略。如果想传递多个值，必须将它们包装在另一个单独的值array或者object</p>
<p>环境，JS函数总是保持他们被定义时所在作用域的闭包，所以它们理所当然地可以继续访问你提供的环境状态。</p>
<h3 id="吞掉所有错误-异常"><a href="#吞掉所有错误-异常" class="headerlink" title="吞掉所有错误/异常"></a>吞掉所有错误/异常</h3><p>如果你用一个 理由（也就是错误消息）拒绝一个Promise，这个值就会被传入拒绝回调。</p>
<p>更重要的事：如果在Promise的创建过程中的任意一点，或者在监听它的解析的过程中，一个JS异常错误发生的话，比如TypeError或ReferenceError，这个异常将会被捕获，并且强制当前的Promise变为拒绝。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	foo.bar();	// `foo`没有定义，所以这是一个错误！</div><div class="line">	resolve( 42 );	// 永远不会跑到这里 :(</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p.then(</div><div class="line">	function fulfilled()&#123;</div><div class="line">		// 永远不会跑到这里 :(</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// `err`将是一个来自`foo.bar()`那一行的`TypeError`异常对象</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>如果Promise完成了，在监听过程中（在then上注册的回调上）出现了异常错误也不会丢失，只是处理方式比较特别<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( 42 );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">p.then(</div><div class="line">	function fulfilled(msg)&#123;</div><div class="line">		foo.bar();</div><div class="line">		console.log( msg );	// 永远不会跑到这里 :(</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 也永远不会跑到这里 :(</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>foo.bar()发生的异常看起来被吞掉了，其实并没有。但更深层次的东西出问题了，也就是我们没能成功地监听他。</p>
<p>p.then()调用本身返回另一个Promise，是那个Promise将会被foo.bar()的TypeError异常拒绝。</p>
<p>为什么不能调用rejected(err)？因为违反了“Promise一旦被解析就<strong>不可变</strong>”的原则。p已经完成为值42，所以不能在监听p的解析时发生错误，在稍后又变成一个拒绝。</p>
<h3 id="可信的Promise？"><a href="#可信的Promise？" class="headerlink" title="可信的Promise？"></a>可信的Promise？</h3><p>基于Promise模式建立信任，还有最后一个细节需要考察。Promise根本没有摆脱回调，只是改变了回调传递的位置。与将一个回调函数传入foo()相反，我们从foo()拿回某些东西，然后我们将回调传入这个东西。</p>
<p>为什么这比直接传入回调可靠？因为 Promise.resolve()</p>
<p>如果传递一个立即的、非Promise的、非thenable的值给Promise.resolve()，你会得到一个用这个值完成的Promise。下面两个Promise p1和p2的行为基本上完全相同：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = new Promise( function(resolve,reject)&#123;</div><div class="line">	resolve( 42 );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p2 = Promise.resolve( 42 );</div></pre></td></tr></table></figure></p>
<p>如果你传递一个纯粹的Promise给Promise.resolve()你会得到一个完全相同的Promise：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">var p1 = Promise.resolve( 42 );</div><div class="line"></div><div class="line">var p2 = Promise.resolve( p1 );</div><div class="line"></div><div class="line">p1 === p2; // true</div></pre></td></tr></table></figure></p>
<p>更重要的是如果你传递一个非Promise的thenable值给Promise.resolve()，它会试着展开这个值，而且直到抽出一个最终具体的非Promise值之前，展开会继续下去。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var p = &#123;</div><div class="line">	then: function(cb,errcb) &#123;</div><div class="line">		cb( 42 );</div><div class="line">		errcb( &quot;evil laugh&quot; );</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">p</div><div class="line">.then(</div><div class="line">	function fulfilled(val)&#123;</div><div class="line">		console.log( val ); // 42</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 噢，这里本不该运行</div><div class="line">		console.log( err ); // evil laugh</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>p是一个thenable但不是一个纯粹的Promise。我们可以将这两个版本的p传入Promise.resolve()，会得到一个期望的泛化、安全的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Promise.resolve( p )</div><div class="line">.then(</div><div class="line">	function fulfilled(val)&#123;</div><div class="line">		console.log( val ); // 42</div><div class="line">	&#125;,</div><div class="line">	function rejected(err)&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>Promise.resolve()会接受任何thenable，得到一个真正的、纯粹的Promise，一个可以信任的东西。反正过滤之后是没有坏处的。</p>
<p>如果在调用一个foo()工具，而且不能确定我们能相信它的返回值是一个行为规范的Promise，但我们知道它是一个thenable。Promise.resolve()将会给我们一个可靠的Promise包装器来进行链式调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">// 不要只是这么做：</div><div class="line">foo( 42 )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">// 相反，这样做：</div><div class="line">Promise.resolve( foo( 42 ) )    // 确保总是返回Promise，将函数调用泛化为一个行为规范的异步任务</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<h2 id="链式流程"><a href="#链式流程" class="headerlink" title="链式流程"></a>链式流程</h2><p>Promise不仅仅是一个单步的 this and then的操作机制，而是构建块。可以将多个Promise串联在一起表达一系列的异步步骤。是一种代码结构和流程。</p>
<p>Promise的核心作用就在于拉平了callback hell的洋葱结构，错误处理和Promise链。规范了异步编程的标准。</p>
<p>Promise的两个固有行为：</p>
<ol>
<li>在一个Promise上调用then()的时候，都创建并返回一个新的Promise，可以在上面进行链接。</li>
<li>无论从then()中的resolve()中返回什么值，都被作为链接的Promise的完成。</li>
</ol>
<p>Promise.resolve()传递一个Promise或thenable时，会直接返回纯粹的Promise或是展开收到的thenable的值——并且递归地持续展开thenable。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">var p = Promise.resolve( 21 );</div><div class="line"></div><div class="line">p.then( function(v)&#123;</div><div class="line">	console.log( v );	// 21</div><div class="line"></div><div class="line">	// 创建一个promise并返回它</div><div class="line">	return new Promise( function(resolve,reject)&#123;</div><div class="line">		// 使用值`42`完成</div><div class="line">		resolve( v * 2 );</div><div class="line">		</div><div class="line">		// 引入异步也是一样正常工作！</div><div class="line">		// setTimeout(function()&#123;</div><div class="line">		//     // 使用值`42`完成</div><div class="line">		//     resolve(v*2);</div><div class="line">		// &#125;, 100);</div><div class="line">	&#125; );</div><div class="line">&#125; )</div><div class="line">.then( function(v)&#123;</div><div class="line">	console.log( v );	// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>要是Promise链中的某一步出错了会怎样呢？一个错误/异常是基于每个Promise的，意味着在链条的任意一点捕获这些错误是可能的，而且这些捕获操作在那一点上将链条“重置”，使它回到正常的操作上来：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">// 步骤 1:</div><div class="line">request( &quot;http://some.url.1/&quot; )</div><div class="line"></div><div class="line">// 步骤 2:</div><div class="line">.then( function(response1)&#123;</div><div class="line">	foo.bar(); // 没有定义，错误！</div><div class="line"></div><div class="line">	// 永远不会跑到这里</div><div class="line">	return request( &quot;http://some.url.2/?v=&quot; + response1 );</div><div class="line">&#125; )</div><div class="line"></div><div class="line">// 步骤 3:</div><div class="line">.then(</div><div class="line">	function fulfilled(response2)&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;,</div><div class="line">	// 拒绝处理器捕捉错误</div><div class="line">	function rejected(err)&#123;</div><div class="line">		console.log( err );	// 来自 `foo.bar()` 的 `TypeError` 错误</div><div class="line">		return 42;          // 完成下一步（第4步）的promise，如此整个链条又回到完成的状态</div><div class="line">	&#125;</div><div class="line">)</div><div class="line"></div><div class="line">// 步骤 4:</div><div class="line">.then( function(msg)&#123;</div><div class="line">	console.log( msg );		// 42</div><div class="line">&#125; );</div></pre></td></tr></table></figure></p>
<p>如果你在一个promise上调用then(..)，而且你只向它传递了一个完成处理器，一个假定的拒绝处理器会取而代之：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">var p = new Promise( function(resolve,reject)&#123;</div><div class="line">	reject( &quot;Oops&quot; );</div><div class="line">&#125; );</div><div class="line"></div><div class="line">var p2 = p.then(</div><div class="line">	function fulfilled()&#123;</div><div class="line">		// 永远不会跑到这里</div><div class="line">	&#125;</div><div class="line">	// 如果忽略或者传入任何非函数的值，</div><div class="line">	// 会有假定有一个这样的拒绝处理器</div><div class="line">	// function(err) &#123;</div><div class="line">	//     throw err;</div><div class="line">	// &#125;</div><div class="line">);</div></pre></td></tr></table></figure></p>
<p>如你所见，这个假定的拒绝处理器仅仅简单地重新抛出错误，它最终强制p2（链接着的promise）用同样的错误进行拒绝。实质上，它允许错误持续地在Promise链上传播，直到遇到一个明确定义的拒绝处理器。完成处理器缺失也是一样的原理，会有一个默认的处理器取而代之直到遇到明确定义的完成处理器</p>
<p>复习一下：使链式流程控制成为可能的Promise固有行为</p>
<ol>
<li>在一个Promise上的.then()调用会自动生成一个新的Promise并返回。</li>
<li>在完成/拒绝处理器内部，如果你返回一个值或抛出一个异常，新返回的Promise（可以被链接的）将会相应地被解析。</li>
<li>如果完成或拒绝处理器返回一个Promise，它会被展开，所以无论它被解析为什么值，这个值都将变成从当前的.then()返回的被链接的Promise的解析。</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://github.com/getify/You-Dont-Know-JS/blob/1ed-zh-CN/async%20&amp;%20performance/ch3.md" target="_blank" rel="external">你不懂JS: 异步与性能 第三章: Promises</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24444262" target="_blank" rel="external">最后谈一次 JavaScript 异步编程</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/29/svg图标在种草社区项目里的实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/29/svg图标在种草社区项目里的实践/" itemprop="url">
                  svg图标在种草社区项目里的实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-29T00:00:00+08:00">
                2017-07-29
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>前端仔对svg这个词应该都不陌生，可缩放的矢量图形，意味着清晰、无损，想来该是越来越高清的手机端的宠儿，然而实际大公司里用的并不多，知乎上也有关于这个问题的<a href="https://www.zhihu.com/question/26865508" target="_blank" rel="external">讨论</a>。即便如此，svg在业界还是备受关注的，也有很多人对其看好，觉得是未来趋势。于是，在种草的最新一期需求里，小试了一把，来谈谈使用过程及感受。</p>
</blockquote>
<p>先扔个扫盲贴，<a href="https://github.com/kaola-fed/blog/issues/36" target="_blank" rel="external">SVG Sprite 使用简介</a>一文类比了icon font，清晰的介绍了svg图标的使用方式。</p>
<h3 id="项目中实践过程"><a href="#项目中实践过程" class="headerlink" title="项目中实践过程"></a>项目中实践过程</h3><ul>
<li><h4 id="收集图标"><a href="#收集图标" class="headerlink" title="收集图标"></a>收集图标</h4></li>
</ul>
<p>在业务功能都码的差不多了，开始想捣腾下svg了，就从设计师那里，要到了本项目的一些svg图标文件，将各个文件换成了英文名后放到了项目的static目录下。</p>
<ul>
<li><h4 id="拼合图标"><a href="#拼合图标" class="headerlink" title="拼合图标"></a>拼合图标</h4></li>
</ul>
<p>查阅了一些文档，发现了一个可以<a href="https://github.com/Hiswe/gulp-svg-symbols" target="_blank" rel="external">将svg图标进行拼合的工具</a>，有点sprite精灵图的意思。于是在项目中安装了下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm i gulp-svg-symbols --save-dev</div></pre></td></tr></table></figure>
<p>注：使用此工具，需要结合gulp构建工具，确保项目中安装了gulp插件</p>
<p>然后设置gulp配置文件，gulpfile.js如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&apos;use strict&apos;;</div><div class="line"></div><div class="line">const &#123;resolve, join&#125; = require(&apos;path&apos;);</div><div class="line"></div><div class="line">var gulp       = require(&apos;gulp&apos;);</div><div class="line">var symbols = require(&apos;gulp-svg-symbols&apos;);</div><div class="line">var wapPath = resolve(__dirname, &apos;src&apos;, &apos;main&apos;, &apos;resources&apos;, &apos;wap&apos;)</div><div class="line">// svg 目录源</div><div class="line">var svgPath = resolve(wapPath, &apos;static&apos;, &apos;svg&apos;)</div><div class="line">// 拼合后的svg输出目录</div><div class="line">var distPath = resolve(wapPath, &apos;dist&apos;, &apos;m&apos;, &apos;svg&apos;)</div><div class="line"></div><div class="line"></div><div class="line">gulp.task(&apos;svgsprites&apos;, function () &#123;</div><div class="line">  return gulp.src(svgPath + &apos;/*.svg&apos;)</div><div class="line">    .pipe(symbols(&#123;&apos;svgClassname&apos;:&apos;svgicon&apos;&#125;))</div><div class="line">    .pipe(gulp.dest(distPath));</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>并在package.json中，配置了此任务：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;scripts&quot;: &#123;</div><div class="line">    &quot;svgsprites&quot;: &quot;gulp svgsprites&quot;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>准备工作差不多了，跑下命令看看结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm run svgsprites</div></pre></td></tr></table></figure></p>
<p>果然，在输出目录下生成了一个<code>svg-symbols.css</code>文件和一个<code>svg-symbols.svg</code>文件，查看了下此svg文件，确认所用的几个图标代码都在此文件里了，就迫不及待的想在业务代码里使用起来：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;svg class=&quot;svg-arrow&quot;&gt;</div><div class="line">  &lt;use xlink:href=&quot;/dist/m/svg/svg-symbols.svg#arrow-rt&quot;&gt;&lt;/use&gt;</div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure>
<p>然后并没有在页面上如期看到图标，于是我又细看了下工具生成的这个svg，类比了其他能正常使用的文件，发现文件头缺少了XLink的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;</div></pre></td></tr></table></figure></p>
<p>看来此工具”年久失修”了，于是只好自己<a href="https://github.com/lzf0402/gulp-svg-symbols" target="_blank" rel="external">fork了一份</a>，改了此工具导出svg所用的模板（/templates/svg-symbols.svg），加上了这串定义，同时在此模板中加了use标签来显示各个图标：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&lt;% if(svgClassname) &#123;%&gt; class=&quot;&lt;%= svgClassname %&gt;&quot;&lt;% &#125; %&gt;&gt;&lt;% if(defs) &#123;%&gt;</div><div class="line">  &lt;defs&gt;</div><div class="line">  	&lt;%= defs %&gt;</div><div class="line">  &lt;/defs&gt;&lt;% &#125; %&gt;</div><div class="line">  &lt;% _.forEach( icons, function( icon )&#123; %&gt;</div><div class="line">  &lt;symbol id=&quot;&lt;%= icon.id %&gt;&quot; viewBox=&quot;&lt;%= icon.svg.viewBox %&gt;&quot;&lt;% if (icon.svg.originalAttributes.preserveAspectRatio) &#123;%&gt; preserveAspectRatio=&quot;&lt;%= icon.svg.originalAttributes.preserveAspectRatio %&gt;&quot; &lt;% &#125;%&gt;&gt;&lt;% if (icon.title) &#123;%&gt;</div><div class="line">      &lt;title&gt;&lt;%= icon.title %&gt;&lt;/title&gt;&lt;% &#125;%&gt;</div><div class="line">      &lt;%= icon.svg.content %&gt;</div><div class="line">  &lt;/symbol&gt;&lt;%</div><div class="line">  &#125;); %&gt;</div><div class="line">  &lt;!-- 添加use标签 显示symbol中定义的图标 --&gt;</div><div class="line">  &lt;% _.forEach( icons, function( icon, idx )&#123; %&gt;</div><div class="line">  &lt;use xlink:href=&quot;#&lt;%= icon.id %&gt;&quot; width=&quot;20&quot; height=&quot;20&quot; x=&quot;0&quot; y=&quot;&lt;%= idx*20 %&gt;&quot; fill=&quot;#666666&quot;&gt;&lt;/use&gt;&lt;%</div><div class="line">  &#125;); %&gt;</div><div class="line"></div><div class="line">&lt;/svg&gt;</div></pre></td></tr></table></figure>
<p>再把这个修改后的工具，发了个npm包—<code>gulp-svg-combine</code>，重新更新工程里的包名和gulp配置，再进行拼合，这次终于可以正常使用了。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>现在拼合后的svg文件已有，只需要在各个使用到的地方像图片一样的引用就可以了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">// 可以把所有图标的样式统一到单个文件里</div><div class="line">.svg-arrow&#123;</div><div class="line">    width: 16px;</div><div class="line">    height: 16px;</div><div class="line">    fill: #666;</div><div class="line">    margin-left: 3px;</div><div class="line">    position: relative;</div><div class="line">    top: 3px;</div><div class="line">&#125;</div><div class="line"></div><div class="line">// ftl中可以直接标签使用</div><div class="line">&lt;svg class=&quot;svg-arrow&quot;&gt;</div><div class="line">  &lt;use xlink:href=&quot;/dist/m/svg/svg-symbols.svg#arrow-rt&quot;&gt;&lt;/use&gt;</div><div class="line">&lt;/svg&gt;</div><div class="line"></div><div class="line">// regular中使用，参考：SVG Sprite 使用简介</div><div class="line">// 定义了r-xlink指令</div><div class="line">&lt;svg class=&quot;svg-zan&quot;&gt;</div><div class="line">  &lt;use r-xlink:href=&quot;/dist/m/svg/svg-symbols.svg#zan&quot;&gt;&lt;/use&gt;</div><div class="line">&lt;/svg&gt;</div><div class="line"></div><div class="line">// 指令动态设置标签的xlink定义</div><div class="line">List.directive(&apos;r-xlink:href&apos;, function(elem, val) &#123;</div><div class="line">    if (val&amp;&amp; val.type === &apos;expression&apos;) &#123;</div><div class="line">        this.$watch(val, function(newVal) &#123;</div><div class="line">            elem.setAttributeNS(&apos;http://www.w3.org/1999/xlink&apos;, &apos;href&apos;, newVal);</div><div class="line">        &#125;);</div><div class="line">    &#125; else &#123;</div><div class="line">        elem.setAttributeNS(&apos;http://www.w3.org/1999/xlink&apos;, &apos;href&apos;, val);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此，算是将svg图标在项目中，实际用起来了，从表现上来说，细看确实会发现对比图片图标或iconfont图标，都要清晰，相信放大之后清晰度的差异更明显，试了各大浏览器和微信中，均表现正常。</p>
<h3 id="使用感受"><a href="#使用感受" class="headerlink" title="使用感受"></a>使用感受</h3><p>下面谈谈一路折腾下来的感受，以及项目中实际使用的一点想法。</p>
<p>对于<a href="https://css-tricks.com/icon-fonts-vs-svg/" target="_blank" rel="external">Inline SVG vs Icon Fonts</a>一文中类比了svg和icon的优劣。</p>
<ul>
<li><p>svg 缩放无损不失真，毋庸置疑，几乎碾压png、iconfont，这也是TA最大的亮点。</p>
</li>
<li><p>css属性方面，iconfont能做到的，svg基本也能做到，同时Ta还能控制图标的部分内容，但实际这种场景应该不多，如果真需要工程师去控制一个小图标里的部分样式，也是工作效率上的一个考验了。</p>
</li>
<li><p>定位方便，虽然svg标签就是其本身的大小，但实际使用中的感受是，图标如果要和文字对其的话，也需要相应的样式控制。</p>
</li>
<li><p>对于iconfont各种原因可能造成字体显示失败的问题，对用户来说确实是不友好的体验，而svg全赖浏览器支持，不支持无非也就不显示内容不会出现乱码之类的情况。目前IE8-以及Android 2.3默认浏览器是不支持SVG的，但可以做一些<a href="一些SVG向下兼容优雅降级技术">fallback</a>。</p>
</li>
<li><p>svg在语义和可访问性方面，确实比iconfont更胜一筹，毕竟svg标签代表着图片，但事实上很多小图标的语义我们<br>并不关心，也不需要浏览器或者屏幕阅读器去过分解读。</p>
</li>
<li><p>性能方面，svg渲染的成本比图片和字体都要来得高。</p>
</li>
</ul>
<p>最后要谈谈使用体验了。</p>
<p>使用svg图标的时候，首先需要通过工具去合并。代码层面，<br>即需要在html中写结构（代码量上会增多），又需要通过选择器来给图标设置一些css属性。相对于使用iconfont，并无效率提升。</p>
<p>设计师直接导出的svg图片，如果不做优化，通过工具合并后的文件会比较大，代码量惊人。而且如果导出的图标被设定死了颜色（fill属性），不做处理的话就无法复用了。当然可以去要求设计师导出的时候遵循一定的标准，但一切人为的操作都是很难保证的。 作为前端，如果花太多精力在处理图标上，实在也不是好的体验。</p>
<p>svg虽然有向下兼容的降级方案，未免麻烦，PC端还是老实用iconfont吧。</p>
<p>以上是自己的一点感想，欢迎拍砖。</p>
<hr>
<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a href="http://leungwensen.github.io/blog/2016/from-icon-fonts-to-svg-icons.html" target="_blank" rel="external">从icon fonts到SVG icons</a></li>
<li><a href="https://css-tricks.com/icon-fonts-vs-svg/" target="_blank" rel="external">Inline SVG vs Icon Fonts</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/27/Redux 基础与实践/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/27/Redux 基础与实践/" itemprop="url">
                  Redux 基础与实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T22:27:31+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前写过一篇 <a href="https://github.com/kaola-fed/blog/issues/103" target="_blank" rel="external">Regular 组件开发的一些建议</a> 的文章提到了日常开发Regular组件的一些槽点，并提出了在简单需求，不使用状态管理框架时的一些替代方案。本文的目的便是填前文的一个坑，即较复杂需求下 Redux 引入方案。</p>
<h1 id="关于-Redux"><a href="#关于-Redux" class="headerlink" title="关于 Redux"></a><a href="http://cn.redux.js.org/index.html" target="_blank" rel="external">关于 Redux</a></h1><blockquote>
<p>Redux 是 JavaScript 状态容器，提供可预测化的状态管理。</p>
</blockquote>
<h1 id="看一个简单的-DEMO"><a href="#看一个简单的-DEMO" class="headerlink" title="看一个简单的 DEMO"></a>看一个简单的 DEMO</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = redux.createStore(<span class="function"><span class="keyword">function</span>(<span class="params">prevState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!prevState) &#123;</div><div class="line">        prevState = &#123;</div><div class="line">            count: <span class="number">0</span></div><div class="line">        &#125;;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="string">'REQUEST'</span>:</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                count: prevState.count + <span class="number">1</span></div><div class="line">            &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> prevState;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.dispatch(&#123;</div><div class="line">    type: <span class="string">'REQUEST'</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">store.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(store.getState());</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>理解他，我们可以结合后端 MVC 的 web 模型<br><img src="https://haitao.nos.netease.com/b9190c99-f5a3-4637-890e-9a597f2099f4.jpeg" alt="web架构"><br><img src="https://haitao.nos.netease.com/d8d909af-b660-48bb-a197-542421332ecc.jpeg" alt="redux架构"></p>
<h1 id="演员表"><a href="#演员表" class="headerlink" title="演员表"></a>演员表</h1><h2 id="Store-饰演-应用服务器"><a href="#Store-饰演-应用服务器" class="headerlink" title="Store 饰演 应用服务器"></a>Store 饰演 应用服务器</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = redux.createStore(f);</div></pre></td></tr></table></figure>
<p>createStore 这个 API 会创建一台应用服务器，包含数据库存储，以及一个 web Server</p>
<h2 id="State-饰演-DataBase"><a href="#State-饰演-DataBase" class="headerlink" title="State 饰演 DataBase"></a>State 饰演 DataBase</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> state = store.getState()</div></pre></td></tr></table></figure>
<p>getState 操作会返回当前的服务器数据库数据，这台数据库 bind 了 0.0.0.0（闭包），所以外界无法操作关于数据库的信息，只能通过内部的服务对数据库做修改</p>
<h2 id="Action-饰演请求"><a href="#Action-饰演请求" class="headerlink" title="Action 饰演请求"></a>Action 饰演请求</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">store.dispatch(&#123;</div><div class="line">    type: <span class="string">'type'</span>,</div><div class="line">    payload: &#123;&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>dispatch(action) 的操作就像是往服务器发送请求。action.type 就像是请求的 uri，action.payload 就像是请求的 body/query。</p>
<h2 id="Reducer-饰演-Controller-Service-DAO"><a href="#Reducer-饰演-Controller-Service-DAO" class="headerlink" title="Reducer 饰演 Controller + Service + DAO"></a>Reducer 饰演 Controller + Service + DAO</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> reducer = <span class="function"><span class="keyword">function</span> (<span class="params">prevState, action</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (!prevState) &#123;</div><div class="line">        <span class="keyword">return</span> &#123;&#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">switch</span>(action.type) &#123;</div><div class="line">        <span class="comment">// 分发处理</span></div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> prevState;</div><div class="line">&#125;</div><div class="line">redux.createStore(reducer);</div></pre></td></tr></table></figure>
<p>相应请求会进入对应的控制器（就像 reducer 的 switch 判断），而控制器内也会对请求携带的信息(payload)做分析，来实现对数据库的增删改查。</p>
<h1 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h1><h2 id="单一数据源"><a href="#单一数据源" class="headerlink" title="单一数据源"></a>单一数据源</h2><blockquote>
<p>整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。</p>
</blockquote>
<p>一般情况下 createStore 创建的 store ，将作用于整个应用</p>
<h2 id="State-是只读的"><a href="#State-是只读的" class="headerlink" title="State 是只读的"></a>State 是只读的</h2><blockquote>
<p>唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。</p>
</blockquote>
<p>避免人为的操作 state 变量，造成状态变化不可预测的情况，人为修改 state 的方式被切断了。</p>
<p>至于如何实现，<a href="https://github.com/ImHype/tiny-redux/blob/master/src/createStore.js#L5" target="_blank" rel="external">点我看源码</a></p>
<p><code>createStore</code> 的操作，会创建一个内部变量 state, 由于 return 出来的 <code>dispatch</code> 和 <code>subscribe</code> 方法保持了对 state 变量的引用，所以 state 会以闭包的形式存活下来。</p>
<h2 id="使用纯函数来执行修改"><a href="#使用纯函数来执行修改" class="headerlink" title="使用纯函数来执行修改"></a>使用纯函数来执行修改</h2><blockquote>
<p>为了描述 action 如何改变 state tree ，你需要编写 reducers。</p>
</blockquote>
<p>使用纯函数，可测试性和可维护性得到了保障。</p>
<h1 id="完成与视图层的绑定"><a href="#完成与视图层的绑定" class="headerlink" title="完成与视图层的绑定"></a>完成与视图层的绑定</h1><p>Redux 职责是状态管理，并非只限定于前端开发，要使用到 web 开发当中，还缺少一个部分，完成 MVC 中剩下的一些操作（渲染页面）。</p>
<p><img src="https://haitao.nos.netease.com/b9190c99-f5a3-4637-890e-9a597f2099f4.jpeg" alt="web架构"><br><img src="https://haitao.nos.netease.com/6f685b72-19bd-4dfd-a191-0de7d0dfa10e.jpg" alt="v-redux架构"></p>
<h2 id="两个重要的-API"><a href="#两个重要的-API" class="headerlink" title="两个重要的 API"></a>两个重要的 API</h2><ul>
<li>store.subscribe(f) - 发布订阅模型， 方法 f 会在 dispatch 触发后执行</li>
<li>store.getState() - return 出当前完整的 state 树</li>
</ul>
<h2 id="简单粗暴的方式"><a href="#简单粗暴的方式" class="headerlink" title="简单粗暴的方式"></a>简单粗暴的方式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> store = redux.createStore(reducer);</div><div class="line"><span class="keyword">const</span> ComponentA = Regular.extend(&#123;</div><div class="line">    config() &#123;</div><div class="line">        <span class="keyword">const</span> ctx = <span class="keyword">this</span>;</div><div class="line">        store.subscribe(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">const</span> state = store.getState();</div><div class="line">            <span class="keyword">const</span> mapData = &#123;</div><div class="line">                clicked: state.clicked,</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">Object</span>.assign(ctx.data, mapData);</div><div class="line">            ctx.$update();</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="两个问题"><a href="#两个问题" class="headerlink" title="两个问题"></a>两个问题</h2><ol>
<li>Store 获取</li>
<li>mapData 与 $update 操作不可复用</li>
</ol>
<h2 id="更优雅的绑定方式"><a href="#更优雅的绑定方式" class="headerlink" title="更优雅的绑定方式"></a>更优雅的绑定方式</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">StoreProvier</span> <span class="attr">store</span>=<span class="string">&#123;store&#125;</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">Component</span>&gt;</span><span class="tag">&lt;/<span class="name">Component</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">StoreProvier</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> Component = connect(&#123;</div><div class="line">    mapState(state) &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            clicked: state.clicked,</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)(Regular.extend(&#123;</div><div class="line">    config() &#123;</div><div class="line">    &#125;</div><div class="line">&#125;))</div></pre></td></tr></table></figure>
<h3 id="1-StoreProvier"><a href="#1-StoreProvier" class="headerlink" title="1. StoreProvier"></a>1. <a href="https://github.com/ImHype/regular-redux-connector/blob/master/src/StoreProvider.js" target="_blank" rel="external">StoreProvier</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Regular.extend(&#123;</div><div class="line">    name: <span class="string">'StoreProvider'</span>,</div><div class="line">    template: <span class="string">'&#123;#include this.$body&#125;'</span>,</div><div class="line">    config(&#123;store&#125; = <span class="keyword">this</span>.data) &#123;</div><div class="line">       <span class="keyword">if</span> (!store) &#123;</div><div class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Provider expected data.store to be store instance created by redux.createStore()'</span>)</div><div class="line">       &#125;</div><div class="line">       </div><div class="line">       store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">           <span class="keyword">this</span>.$update();</div><div class="line">       &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h3 id="2-connect"><a href="#2-connect" class="headerlink" title="2. connect"></a>2. <a href="https://github.com/ImHype/regular-redux-connector/blob/master/src/connect.js" target="_blank" rel="external">connect</a></h3><blockquote>
<p>统一从最外层的 StoreProvider 组件获取 store，保证单一数据源</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStore</span>(<span class="params">ctx</span>) </span>&#123;</div><div class="line">    <span class="keyword">let</span> parent = ctx.$parent;</div><div class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (!parent) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Expected root Component be Provider!'</span>)</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (parent.data.store) &#123;</div><div class="line">            <span class="keyword">return</span> parent.data.store;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        parent = parent.$parent;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">connect</span>(<span class="params">&#123;</span></span></div><div class="line"><span class="function"><span class="params">    mapState = (</span>) =&gt; (<span class="params">&#123;&#125;</span>),</span></div><div class="line"><span class="function">    <span class="title">dispatch</span></span></div><div class="line"><span class="function">&#125; = </span>&#123;&#125;) &#123;</div><div class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">Component</span>) =&gt;</span> Component.implement(&#123;</div><div class="line">        events: &#123;</div><div class="line">            $config(data = <span class="keyword">this</span>.data) &#123;</div><div class="line">                <span class="keyword">const</span> store = getStore(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">const</span> mapStateFn = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">                    <span class="keyword">const</span> state = store.getState();</div><div class="line">                    <span class="keyword">const</span> mappedData = mapState.call(<span class="keyword">this</span>, state);</div><div class="line">                    mappedData &amp;&amp; <span class="built_in">Object</span>.assign(<span class="keyword">this</span>.data, mappedData);</div><div class="line">                &#125;</div><div class="line">                mapStateFn();</div><div class="line"></div><div class="line">                <span class="keyword">const</span> unSubscribe = store.subscribe(mapStateFn);</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (dispatch) &#123;</div><div class="line">                    <span class="keyword">this</span>.$dispatch = store.dispatch;</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="keyword">this</span>.$on(<span class="string">'destroy'</span>, unSubscribe);</div><div class="line">            &#125; </div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>至此回过头看 regualr-redux 的架构图，发现正是 <code>StoreProvier</code> 和 <code>connect</code> 操作帮助 <code>redux</code> 完成了与 MVC 相差的更新视图操作。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>借助 redux 与特定框架的连接器，我们会发现，对特定 MVVM 框架的要求会变得很低 – mapState 操作可以完成 类似 Vue 中 computed/filter 的操作。</p>
<p>所以，如今还在半残废中的微信小程序也很适合基于这套思路来结合 redux (逃)。</p>
<p>带来的好处是，你可以安心维护你的模型层，不用担心 <code>data</code> 过大导致的脏值检查缓慢，也不需要考虑一些逻辑相关的数据不放入 <code>data</code> 那该放入何处。</p>
<p>相信阅读此文，你会对 <code>Redux</code> 解决问题的方式有了一定的认识，而继续深入的一些方向有:</p>
<ul>
<li><a href="http://cn.redux.js.org/docs/advanced/Middleware.html" target="_blank" rel="external">middleway</a> 实现原理，redux-logger 和 redux-thunk 等实现方案；</li>
<li><a href="http://cn.redux.js.org/docs/recipes/reducers/NormalizingStateShape.html" target="_blank" rel="external">State 范式化</a>；</li>
<li><a href="https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0" target="_blank" rel="external">Presentational and Container Components</a></li>
<li>单页的 redux 架构设计</li>
</ul>
<p>全文完 ；）</p>
<p>by <a href="http://github.com/imhype/" target="_blank" rel="external">君羽</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/27/Regular 组件开发的一些建议/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/27/Regular 组件开发的一些建议/" itemprop="url">
                  Regular 组件开发的一些建议
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-27T22:27:31+08:00">
                2017-07-27
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>近几年来，前端开发这个概念发生了明显的变化。多年以前，前端开发的重点可能是使用 HTML/CSS/JS 和一些兼容知识来完成页面的构建，动效的制作。</p>
<p>而现阶段的前端开发，工作的很重要的部分，就是使用 Vue/React 或其他 MVVM 框架来完成我们的组件，并组织我们的页面。</p>
<p>我们来进入现实的开发场景。你接手一个需求后，最先做的是什么？</p>
<p>如果是一个新项目，你可能需要思考一些架构上的东西，比如：是否启用单页架构、使用什么开发框架、是否需要状态管理工具、资源构建怎么处理。嗯，你会饶有乐趣，然后兴致满满地开工。</p>
<p>事实上，新的项目并不多，我们更多时候也都是在维护现有代码，可能有很多事情会让你你觉得无奈的。比如，你对现有架构的不满意，对当前的业务逻辑书写得这么复杂表示不理解。于是，你想要重构。当然，我也希望重构。但是，我们的生命是否允许你消耗这段时间来重构这段老的逻辑。答案，是否。</p>
<p>所以，更重要地就是，阻止更多的代码恶化，这似乎比你单枪匹马搞重构，有用的多。这也是本文的重点，如何在现有项目，新需求的场景下，书写更可维护的组件化代码。</p>
<h2 id="关于-RegularJS-开发的一些槽点"><a href="#关于-RegularJS-开发的一些槽点" class="headerlink" title="关于 RegularJS 开发的一些槽点"></a>关于 RegularJS 开发的一些槽点</h2><p>RegularJS 是网易出品的一款 MVVM 框架，本身其设计思路，和学习成本，都算中上。但是，作者对于设计思路在文档中的体现太少，导致顺势而为的使用者不多。比如说，下面的一些用法：</p>
<h3 id="1-过度庞大的组件"><a href="#1-过度庞大的组件" class="headerlink" title="1. 过度庞大的组件"></a>1. 过度庞大的组件</h3><h4 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h4><p>一个组件，原本可以拆成若干个组件来单独处理 UI 和 行为，现在被放到了一个组件里，使得组件过大，导致维护性、扩展性降低。</p>
<h4 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h4><p>组件拆分有很多原则可以参考：</p>
<ol>
<li>六大设计原则的 「单一职责原则」，尽可能保证每个组件的职责单一性；</li>
<li>当前比较盛行的 「容器组件」与「UI 组件」的方案，「容器组件」用于控制用户状态，并做一些数据更新操作，不直接表现UI；「UI组件」则主要负责 UI 展现，不做具体的逻辑处理，需要更新数据，尽可能使用事件，交给容器组件处理；</li>
</ol>
<h3 id="2-组件原型上存放一些原本可以抽出的方法"><a href="#2-组件原型上存放一些原本可以抽出的方法" class="headerlink" title="2. 组件原型上存放一些原本可以抽出的方法"></a>2. 组件原型上存放一些原本可以抽出的方法</h3><h4 id="描述-1"><a href="#描述-1" class="headerlink" title="描述"></a>描述</h4><p>组件原型链上放置了过多不属于 <code>this</code> 的处理逻辑，导致组件的可维护性与可理解性降低。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> ComponentA = Regular.extend(&#123;</div><div class="line">    getList() &#123;</div><div class="line">        <span class="keyword">this</span>.$request(&#123;</div><div class="line">            url,</div><div class="line">            success(&#123;</div><div class="line">                code, body</div><div class="line">            &#125;) &#123;</div><div class="line">                <span class="keyword">if</span> (code === <span class="number">200</span>) &#123;</div><div class="line">                    <span class="keyword">this</span>.getListCallBack();</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    getListCallBack(&#123;list&#125;) &#123;</div><div class="line">        <span class="keyword">this</span>.filterList(list);</div><div class="line">    &#125;,</div><div class="line">    filterList(list) &#123;</div><div class="line">        <span class="keyword">this</span>.data.list = list.map(<span class="function">(<span class="params">&#123;title, content&#125;</span>) =&gt;</span> &#123;</div><div class="line">            <span class="keyword">return</span> &#123;</div><div class="line">                title, content</div><div class="line">            &#125;;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h4 id="建议-1"><a href="#建议-1" class="headerlink" title="建议"></a>建议</h4><p>纯函数对于可测试性和可预期性都有较大的优势。</p>
<p>所以，不如把一些无关 <code>this</code> 的方法抽出来吧，把他们作为一些纯函数在你的组件生命周期中调用。</p>
<p>比如，把发 Ajax 请求的方法抽成 service，统一管理，把一些对象处理函数独立成 filter，总之 this 上尽可能的干净，对后期的维护是很有帮助的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> filterList(list) &#123;</div><div class="line">    <span class="keyword">return</span> list.map(<span class="function">(<span class="params">&#123;title, content&#125;</span>) =&gt;</span> &#123;</div><div class="line">        <span class="keyword">return</span> &#123;</div><div class="line">            title, content</div><div class="line">        &#125;;</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">const</span> ComponentA = Regular.extend(&#123;</div><div class="line">    computed: &#123;</div><div class="line">        title()&#123;</div><div class="line">            <span class="keyword">this</span>.getTitles();</div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    onButtonClick() &#123;</div><div class="line">        service.getList(&#123;</div><div class="line"></div><div class="line">        &#125;).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">            <span class="keyword">this</span>.setList(list);</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    setList(&#123;list&#125;) &#123;</div><div class="line">        <span class="keyword">this</span>.data.list = filterList(list);</div><div class="line">    &#125;,</div><div class="line">    getTitles() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.data.list.map(<span class="function"><span class="params">item</span> =&gt;</span> item.title);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>一般三类方法是必须的 1. 事件 handler; 2. compute get 方法; 3. data 的操作方法</p>
</blockquote>
<ol>
<li>事件 handler 可以让你的函数更贴近于事件编程方式，更便于理解；</li>
<li>使用 set 方法去设置 data 的数据，可以让你的 data 修改更可控；</li>
<li>将 computed 抽出成方法，可以在 js 中复用 computed 的逻辑；</li>
</ol>
<p>原则就是，能挪出去的就挪出去作为纯函数。</p>
<h3 id="3-滥用双向绑定"><a href="#3-滥用双向绑定" class="headerlink" title="3. 滥用双向绑定"></a>3. 滥用双向绑定</h3><h4 id="描述-2"><a href="#描述-2" class="headerlink" title="描述"></a>描述</h4><p>双向绑定，是指数据更新与UI行为的绑定操作。经常会出现一个对象依次传入多层组件的情况，这时候最省力的数据更新方式，可能就是直接在子组件内修改这个对象。</p>
<p>Index 组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ComponentA obj=&#123;obj&#125;&gt;&lt;/ComponentA&gt;</div></pre></td></tr></table></figure></p>
<p>ComponentA 组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ComponentB obj=&#123;obj&#125;&gt;&lt;/ComponentB&gt;</div></pre></td></tr></table></figure></p>
<p>ComponentB 组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;ComponentC obj=&#123;obj&#125;&gt;&lt;/ComponentC&gt;</div></pre></td></tr></table></figure></p>
<p>ComponentC 组件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;input r-model=&#123;obj.a&#125;/&gt;</div></pre></td></tr></table></figure></p>
<p>我们看到如上这种情况，看似很巧妙的结合 RegularJS 的双向绑定，做了数据更新的操作，也能让最外层组件可以使用最新的 obj 对象做一些事情。但是，对于最外层组件而言， obj 的变化是不可预期的。换言之，开发者很难通过直接查看最外层组件，感知到 obj 对象可能发生的改变。这也是，双向绑定带来的弊端。</p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>双向绑定的使用，非常方便，在深层嵌套的组件数据传递上，尤为明显。但它会使得数据的改变源头难以追踪，代码接手时也容易留坑，不好理解。</p>
<p>那么，我们应该控制住自己，不要过分依赖这种能力。换句话说，如果你肯定你的项目是不需要被维护的，那么你去使用吧（逃）</p>
<p>一般场景下，单向数据流的启用方式，是通过事件。</p>
<p>ComponentA</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ComponentB</span></span></div><div class="line"><span class="tag">    <span class="attr">obj</span>=<span class="string">&#123;obj&#125;</span></span></div><div class="line"><span class="tag">    <span class="attr">on-btnClick</span>=<span class="string">&#123;&#125;</span></span></div><div class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">ComponentB</span>&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">Regular.extend(&#123;</div><div class="line">    config() &#123;</div><div class="line">        extend(<span class="keyword">this</span>.data, &#123;</div><div class="line">            obj: &#123;</div><div class="line">                clicked: <span class="literal">false</span></div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">    &#125;,</div><div class="line">    onComponentBBtnClick() &#123;</div><div class="line">        <span class="keyword">this</span>.setClicked();</div><div class="line">    &#125;</div><div class="line">    setClicked() &#123;</div><div class="line">        <span class="keyword">this</span>.data.obj.clicked = <span class="literal">true</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<hr>
<p>ComponentB<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">disable</span>=<span class="string">&#123;clicked&#125;</span> <span class="attr">on-click</span>=<span class="string">&#123;this.$emit(</span>'<span class="attr">btnClick</span>')&#125;&gt;</span>点我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>那么，如何解决深层嵌套组件的数据更新问题呢，就是使用状态管理工具，后面会提到。</p>
<h3 id="4-习惯把所有数据都放置到-this-data-上"><a href="#4-习惯把所有数据都放置到-this-data-上" class="headerlink" title="4. 习惯把所有数据都放置到 this.data 上"></a>4. 习惯把所有数据都放置到 <code>this.data</code> 上</h3><h4 id="描述-3"><a href="#描述-3" class="headerlink" title="描述"></a>描述</h4><p>习惯把所有数据都挂载到 <code>this.data</code> 上。</p>
<p>如果我们正视 data 的职责，data 只负责放置 UI 渲染相关数据。那么，我们平时开发中，很多操作是存在争议的：</p>
<ol>
<li>请求获取下来的数据，直接放置到 this.data 上的方式，后端在提供在前端的数据中，难免会存在一些冗余的字段，会直接赋值到 data 上，最直接的影响是导致脏值检查耗时增加，这些字段的存在会让你的 data 显得凌乱不清晰；</li>
<li>大家可能会将一些逻辑计算的数据也放置到 data 上，但是这些数据对于模板渲染也是无关的。</li>
</ol>
<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>这个问题的关键，是正确地认知 <code>this.data</code>。对于 MVVM 框架而言，最大的亮点莫过于视图与数据的绑定（单向 or 双向）， <code>this.data</code> 他真正的职责就是作为视图层渲染时提供必要的数据。</p>
<p>那么，你可能就能理解一些类似的话了：<br>「React只是一个优秀的视图层框架，他将复杂的状态管理留给了你」</p>
<p>所以，原则上不该把所有数据都放置到 <code>data</code> 上。其次，可以根据 1 中提到的方案，使用 「容器组件」和「UI组件」的分类，来区分我们的组件状态。</p>
<ul>
<li>「容器组件」可以放置一些逻辑处理相关的字段，用于与后端交互和分发组件。</li>
<li>「UI 组件」的 <code>data</code> 应该避免赋值一些视图无关的状态。</li>
</ul>
<p>当然，必要时，推荐引入状态管理工具来管理你的状态。</p>
<h3 id="5-组件传入的参数结构不明了"><a href="#5-组件传入的参数结构不明了" class="headerlink" title="5. 组件传入的参数结构不明了"></a>5. 组件传入的参数结构不明了</h3><h4 id="描述-4"><a href="#描述-4" class="headerlink" title="描述"></a>描述</h4><p>Index<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ComponentA</span> <span class="attr">obj</span>=<span class="string">&#123;obj&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">ComponentA</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>组件 ComponentA 的传入参数是 obj，但是 obj 对于调用者来说，是一个黑盒。直接阅读该组件的例子或现有代码，无法直接地了解到该组件的使用姿势。</p>
<h4 id="解决-2"><a href="#解决-2" class="headerlink" title="解决"></a>解决</h4><p>所以，尽可能地直接明了地展现组件所需的属性，同时需要遵守遵守程序设计的「迪米特法则（最少知道原则）」，让所需的属性尽可能的少。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">ComponentA</span> </span></div><div class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&#123;name&#125;</span></span></div><div class="line"><span class="tag">    <span class="attr">age</span>=<span class="string">&#123;age&#125;</span></span></div><div class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">ComponentA</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="6-较长的表达式"><a href="#6-较长的表达式" class="headerlink" title="6. 较长的表达式"></a>6. 较长的表达式</h3><h4 id="描述-5"><a href="#描述-5" class="headerlink" title="描述"></a>描述</h4><p>Index<br><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;#list coupons as coupon&#125;</div><div class="line">    使用条件：&#123;coupon.couponType === 1 ? `满¥ $&#123;coupon.threshold&#125; 使用` : '无条件使用'&#125;</div><div class="line">&#123;/list&#125;</div></pre></td></tr></table></figure></p>
<h4 id="解决-3"><a href="#解决-3" class="headerlink" title="解决"></a>解决</h4><p>模板中不该存在过多的计算逻辑，很重要一点是，我们一般无法对模板进行 debug，所以将逻辑抽出安放到 filter 或 computed 中，是个不错的方式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Regular.extend(&#123;</div><div class="line">    template: <span class="string">`</span></div><div class="line"><span class="string">    &#123;#list coupons as coupon&#125;</span></div><div class="line"><span class="string">        使用条件：&#123;coupon|getCouponCondition&#125;</span></div><div class="line"><span class="string">    &#123;/list&#125;</span></div><div class="line"><span class="string">    `</span>,</div><div class="line">&#125;).filter(&#123;</div><div class="line">    getCouponCondition(coupon) &#123;</div><div class="line">        <span class="keyword">return</span> coupon.couponType === <span class="number">1</span> ? <span class="string">`满¥ <span class="subst">$&#123;coupon.threshold&#125;</span> 使用`</span> : <span class="string">'无条件使用'</span>;</div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>篇幅原因，简单列举几条。</p>
<p>书写可维护的 Regular 组件，需要我们有关于设计基本原则的一些理解，并在实际的 MVVM 框架下展开。</p>
<p>有接触过 Redux 的同学，可能会发现，上述的一些解决方案，有很多是借鉴自 Redux 的，如 单向数据流 、「容器组件」与「UI 组件」。那么如何使用状态管理来更为优雅地解决这些问题，本人另一篇文章 <a href="">Redux基础与实践</a> 正在飞奔而来！！！</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/26/不同加载方式的js脚本执行顺序的观察/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/26/不同加载方式的js脚本执行顺序的观察/" itemprop="url">
                  不同加载方式的js脚本执行顺序的观察
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-26T00:00:00+08:00">
                2017-07-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 为了更方便归档，请先完善以上信息，正文贴下面 -->
<!--
注意点：
0. 文章中的资源（主要是图片）引用请使用 HTTPS
1. 文章末可以加上自己的署名，如： by [Kaola](http://www.kaola.com)
2. 最好不要用 NOS 图床，感觉加防盗链是迟早的事
3. 文章会定期归档到 https://blog.kaolafed.com/
-->
<p>首先思考几个问题:</p>
<ul>
<li>1.内联脚本和标签引入的脚本, 哪个先执行?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;script src=&quot;a.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;script&gt;</div><div class="line">console.info(&apos;this is inline&apos;);</div><div class="line">&lt;/script&gt;</div></pre></td></tr></table></figure>
<ul>
<li>2.用内联脚本动态向页面中append一个脚本, 并给脚本注册onload回调, 脚本的内容和onload哪个先执行?</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            console.info(&apos;this is inline&apos;);</div><div class="line">            var script = document.createElement(&apos;script&apos;);</div><div class="line">            script.src = &apos;a.js&apos;;</div><div class="line">            script.onload = function() &#123;</div><div class="line">                console.info(&apos;onload&apos;);</div><div class="line">            &#125;</div><div class="line">            document.body.appendChild(script);</div><div class="line">&lt;/script&gt;</div><div class="line"></div><div class="line">// a.js</div><div class="line">(function() &#123;</div><div class="line">    console.info(&apos;this is a&apos;);</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<ul>
<li><p>3.向页面中append一个脚本后, 再把这个脚本remove掉, 脚本会执行吗? </p>
</li>
<li><p>4.如果写一个第三方库, 要在库加载的时候获取一些信息, 这些信息可以写到引入库的script标签上吗?</p>
</li>
</ul>
<p>下面提供三个代码, 解答前三个问题:</p>
<p>page.html</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html&gt;</div><div class="line">    &lt;head&gt;</div><div class="line">        &lt;meta charset=&quot;utf-8&quot;&gt;</div><div class="line">        &lt;title&gt;&lt;/title&gt;</div><div class="line">    &lt;/head&gt;</div><div class="line">    &lt;body&gt;</div><div class="line">        &lt;script type=&quot;text/javascript&quot;&gt;</div><div class="line">            console.info(&apos;this is inline&apos;);</div><div class="line">            var script = document.createElement(&apos;script&apos;);</div><div class="line">            script.src = &apos;a.js&apos;;</div><div class="line">            script.onload = function() &#123;</div><div class="line">                console.info(&apos;onload&apos;);</div><div class="line">            &#125;</div><div class="line">            script.id = &apos;abc&apos;;</div><div class="line">            document.body.appendChild(script);</div><div class="line">            console.info(&apos;append&apos;);</div><div class="line">        &lt;/script&gt;</div><div class="line">        &lt;script src=&quot;b.js&quot;&gt;&lt;/script&gt;</div><div class="line">        &lt;script&gt;</div><div class="line">          console.info(&apos;inline2&apos;);</div><div class="line">        &lt;/script&gt;</div><div class="line">    &lt;/body&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure>
<p>a.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    console.info(&apos;this is a&apos;);</div><div class="line">    var script = document.querySelector(&apos;#abc&apos;);</div><div class="line">    console.info(script);</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>b.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(function() &#123;</div><div class="line">    console.info(&apos;this is b&apos;);</div><div class="line">    var script = document.querySelector(&apos;#abc&apos;);</div><div class="line">    document.body.removeChild(script);</div><div class="line">    console.info(&apos;removed&apos;);</div><div class="line">&#125;())</div></pre></td></tr></table></figure>
<p>结论: </p>
<ol>
<li>内联脚本和标签脚本的执行顺序, 由脚本在页面中的位置确定;</li>
<li>动态加载的脚本, 脚本内容会先执行, onload后执行;</li>
<li>动态加载的脚本会在所有标签脚本执行后执行, 只要append了脚本, 即使马上removeChild把脚本所在的标签删掉, 脚本也会执行; 只是脚本无法获取到自己所在的标签了.</li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://blog.kaolafed.com/2017/07/16/关于Git冲突解决引入问题的思考/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="考拉前端团队">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="考拉前端团队博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/07/16/关于Git冲突解决引入问题的思考/" itemprop="url">
                  关于Git冲突解决引入问题的思考
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-16T16:54:37+08:00">
                2017-07-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>最近团队里连续出现几次代码合并问题，结合其他开发组的线上问题总结，代码冲突导致的问题确实是比较常见的一个原因，这个不得不让我们去思考，如何才能杜绝这类低级问题。</p>
<p>我们采用的是 <code>master</code> + <code>develop</code> + <code>feature</code> + <code>hotfix</code> 四类分支开发的方式，特性开发与问题修复很可能改动到相同的文件，工作中Git代码冲突比较常见；比如一个开发人员正在做购物车的一个新特性开发，同时线上发现问题或者紧急需求插进来，需快速处理，这个时候就会导致一个文件在不同分支都有改动。</p>
<p>从我们的工作流程上来说，开发+测试都是在特性分支上做，接近测试完成了才将代码合并到主干分支（develop或者master）；代码合并导致的问题，一般都发生在特性、修复分支合并到master或者develop的时候，因为这个时候开始，才是真正与其他分支汇合，不同的改动会发生冲突；而此时开发+测试都会认为功能基本没有问题了，就算测试在集成环境回归一遍，也不会像开发分支上那么仔细的测试，所以合并导致的问题也比较容易带入到线上。</p>
<p>既然合并没法完全避免，我们只能去思考如何减少合并冲突，以及冲突解决的时候如何减少问题；</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2017/07/16/关于Git冲突解决引入问题的思考/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="考拉前端团队" />
          <p class="site-author-name" itemprop="name">考拉前端团队</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">98</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">考拉前端团队</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

</body>
</html>
